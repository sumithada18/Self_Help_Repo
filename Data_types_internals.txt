 Understanding of *char*
A char is an integer data type that is 1 byte (8 bits), providing 2^8 (256) unique bit patterns. Its primary job is to store characters, 
but it's fundamentally a small integer.

The C++ standard does not specify if a plain char is signed or unsigned; this is platform-dependent.

-> An unsigned char uses all 256 patterns to store numbers from 0 to 255.
-> A signed char splits the patterns to store numbers from -128 to 127.

Overflow happens when a value goes outside these ranges.

-> For unsigned char: Overflow is well-defined. The value predictably wraps around. 255 + 1 becomes 0. This can cause logical issues.
-> For signed char: Overflow triggers Undefined Behavior (UB). You must avoid this, as the result is unpredictable and dangerous.

Printing with std::cout:
The most unique aspect of char is how it's treated by output streams.
-> std::cout << my_char; will print the character symbol corresponding to the integer value (e.g., the value 65 prints as the character 'A').
-> std::cout << (int)my_char; is required to see the actual integer value stored in the variable.

Practical Rules:
-> Use a plain char for storing standard text characters.
-> Use an unsigned char when you need a small, non-negative integer from 0-255 or are working with raw binary data.
-> Use a signed char when you need a very small integer that could be negative.






Understanding of *int*
An int is typically 4 bytes (32 bits), which provides 2^32 unique bit patterns. How these patterns are used depends on whether the int is 
signed or unsigned.

-> An unsigned int uses all 2^32 patterns to store numbers from 0 to 4,294,967,295 (which is 2^32 - 1).
-> A signed int splits the patterns to store numbers from -2,147,483,648 to +2,147,483,647 (which is -2^31 to 2^31 - 1).

Overflow is what happens when a calculation's result falls outside these ranges. The consequences are critically different:
-> For unsigned int: Overflow is not a compiler error. The value predictably wraps around (modulo arithmetic). This is a well-defined behavior, but 
   it often creates a serious runtime logical issue because the result is mathematically incorrect.
-> For signed int: Overflow does not give a guaranteed error. It triggers Undefined Behavior (UB).
  - The Reason (Why it's UB): The C++ standard allows the compiler to assume that signed overflow will never happen. This lets the compiler perform 
    aggressive optimizations. Because of this assumption, when overflow does happen, the program is in an invalid state, and the result is completely 
    unpredictable—it might crash, corrupt data, or create a security vulnerability.

Practical Rules:
-> Use a signed int (the default) for general numbers that can be negative. You must write code to prevent overflow because the consequence is 
   dangerous Undefined Behavior.
-> Use an unsigned int only when you need a value that can never be negative (like an array index or a memory size) and you understand the wrap-around behavior.

//==========================================================================================
unsigned int x = UINT_MAX; // 4294967295 (for 32-bit)
x = x + 1; // Wraps to 0 — fine

int y = INT_MAX; // 2147483647
y = y + 1; // Undefined behavior — compiler error or weird output
//==========================================================================================



